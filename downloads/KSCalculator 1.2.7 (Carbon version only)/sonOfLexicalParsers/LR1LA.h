#pragma	once//	Knowledge Software Consulting	© Paul Beeken, 1999  Work in Progress.//--------------------// The idea is to build a parser that will take a simple calculation expression//	and return a result.  The input is a string.  The output a string representing//	the result of the calculations.//	I impose a couple of constraints on the lexicon, parser and compiler. 1) I don't//	want linked lists.  2) the lexicon must be simple.  3) it need only//	be left associative.//	It should be obvious to anyone familiar with parsing that I got alot of help from//	the "Dragon Book", Thanks guys.  //--------------------//	Parser...//		This implementation of a string translator allows the caller to track the//		position of the indicator.  It takes a pointer to a null terminated string//		or position indicator and scans forward spining out tokens.  The caller is//		responsible for makeing space for the tokens.//	The grammar for this is://	tok -> num op//	num -> [0-9.]//	op	-> [+-*/¡¼"']#include	<MacTypes.h>#include	"Parser.h"#if DONT_USE_TRY_CATCH#include	<setjmp.h>#endifconst	short kTupStackSize	=	50;//// This is the calculatior object that translates a calculational string into a result.//class	LR1LA	: public Parser {	public:		// We instantiate with an arbitrary string of a calculated result.		LR1LA( char* inString=nil );		virtual ~LR1LA();				// Compile the string.		void	Compile( char* inString=nil );		// Get the Answer, returns false if there was an error.		bool	Answer( char* theResult );#if DEBUG || DEBUG_STACK_TRACE				// Debug Function		void	DumpToken( Tuple t, bool sIdx=false );#endif	protected:		Tuple	tupStack[kTupStackSize];		Tuple	currentToken;		short	stackIndex;		char	errorMsg[256];#if DONT_USE_TRY_CATCH//		jmp_buf env;		#endif	private:		// For exposure only, intended as a private function.		char*	lexical( char* in, char* tokStr );				void	parse();		void	expr();		void	term();		void	factor();		void	value();		void	match( unsigned short t );		void	match( Tuple& t )			{ match( t.getType() ); }		void	emit( Tuple& t );		void	error( char* s );		void	checkStack();		Tuple	result()					{ return tupStack[stackIndex]; }		void	operateFunction( short f );		short	findFunction( Tuple& t );		bool	existsError()		{ return errorMsg[0] != '\0'; }				};
#include	<cstring>#include	<cctype>#include	"Parser.h"const	char	EOS	=	'\0';using namespace std;Parser::Parser( char* in )	{	strcpy( mFormat, "%f" );	SetStream( in );	mHasLookAhead	= false;	mThousands = ',';	mDecimal = '.';}Parser::~Parser()	{}voidParser::SetStream( char* in )	{	mCurrPos = mInString = in;		// prescan for semi-colon	for( ; *mCurrPos; mCurrPos++ )		if ( *mCurrPos == ';' ) 			break;		if ( *mCurrPos == ';' ) {		*mCurrPos++ = '\0';		for( short i=0; *mCurrPos && i<20; i++ ) {			mFormat[i] = *mCurrPos++;			mFormat[i+1] = EOS;			}		}	mCurrPos = in;	}//*******************************************************************//	tokens					method							[private]//		Builds the inital token stream from a supplied string.//	Create the conditioned stream.//	We can allow this in the constructor since there are no real errors here.  Any//	string will make it into the preliminray parsed array.//	We will do some preprocessing here.  For example.  A number in front//	of a parentheses or function will have an implied multiply.  We also//	distinguish the unary operations here.  //	e.g.	3 ( ...  -> 3 * (  and ) 6 -> ) * 6.//	Remember this is still part of the one pass compiler there is no tree//	generation here.  We are simply pre-processing and conditioning the//	input stream.  This is valuable since we can do some preprocessing,//	the resulting token string can then be processed without as much error//	checking on the second pass.  The preprocessor only requires at most O(K*n) operations//	where n is the number of characters and K is the number of preprocessor commands.//	The savings comes from the simplification of the actual translator.//*******************************************************************Tuple&Parser::GetToken()	{	// No tokens.	if ( mInString == 0L )	{		Tuple tmp(Terminal);		mLookAhead = tmp;		return mLookAhead;		}	// If we have a lookahead value, return it.	if ( mHasLookAhead ) {		mHasLookAhead = false;		return mLookAhead;		}	// otherwise generate a new one.	char	tokenStr[255];	lexical( tokenStr );	Tuple tmpTuple(tokenStr);	mLookAhead = tmpTuple;	return mLookAhead;}//*******************************************************************//	lexical					method							[private]// This is the first step in the parser: the lexical analyzer.//	It reduces the string into smaller lexical chuncks for later tokenization.//	It starts with a pointer to a null terminated string and returns a pointer//	as to where in the string it stopped.  This is where a one pass compiler would//	also perform lookahead analysis to determine what token to assign but I want//	greater modularity.  This routine cannot really fail since all it does is collect//	lexical elements. It is intended to be completely deterministic.//// The grammar for this translator is//	tok			-> operator | string | num//	num			-> [0-9.eE]+//	name		-> [a-zA-Z][a-zA-Z0-9]+//	operator	-> anything else as a single character//*******************************************************************void	Parser::lexical( char* tokStr )	{		char*	bt = tokStr;		*tokStr = EOS;	// nil terminate by default	char 	cc = getChar();	if ( cc == EOS )		return;		// universal signal to indicate the end of the line.	while( cc ) {		// **** Collect digits and decimals into one token.		if ( isdigit( cc ) || cc == mDecimal ) {			if ( cc == mDecimal ) // force a preceeding 0.				*tokStr++ = '0';			// Collect all the digits including any decimal places.			while ( isdigit( cc ) || cc == mDecimal || cc == mThousands || cc == 'E' || cc == 'e' ) { // scientific notation				if ( cc == 'E' || cc == 'e' ) {					*tokStr++ = cc;					char nc = getChar();					if ( nc == '-' || nc == '+' )						*tokStr++ = nc;					else						pushBack();					}				else				if ( cc != mThousands )	{ // ignore thousands separator.					if ( cc == mDecimal )						cc = '.'; // POSIX unix standard decimal character.					*tokStr++ = cc;					}				else				if ( cc == mThousands && !isdigit(peekChar()) ) // There is some kind of syntax problem.					break;								cc = getChar();				*tokStr = EOS;				}			pushBack();	// push back the terminal character that got us here.			break;	// we are done.			}		// **** Skip whitespace.		else		if ( isspace( cc ) )	{			;// Do Nothing!			}		// **** Collect any string started as an alpha and numbers into one token.		else		if ( isalpha( cc ) ) {			// Collect all the characters including any digits places.			while ( isalnum( cc ) ) {				*tokStr++ = cc; // make no interpretation on the characters (let the token enigne do this)				*tokStr = EOS;				cc = getChar();				}			pushBack();	// push back the terminal character that go us here.			break;	// we are done.			}		// **** Collect a single character and return as a single element.		else	{			// return a single token.			*tokStr++ = cc;			*tokStr = EOS;			break;			}		// Next!		cc = getChar();		}	}
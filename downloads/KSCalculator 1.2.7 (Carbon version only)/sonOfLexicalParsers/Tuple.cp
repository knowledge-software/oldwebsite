//	Knowledge Software Consulting	© Paul Beeken, 1999  Work in Progress.//--------------------// The idea is to build a parser that will take a simple calculation expression//	and return a result.  The input is a string.  The output a string representing//	the result of the calculations.//	I impose a couple of constraints on the lexicon, parser and compiler. 1) I don't//	want linked lists.  2) the lexicon must be simple.  3) it need only//	be left associative.//	It should be obvious to anyone familiar with parsing that I got alot of help from//	the "Dragon Book", Thanks guys.  //--------------------//	Parser...//		This implementation of a string translator allows the caller to track the//		position of the indicator.  It takes a pointer to a null terminated string//		or position indicator and scans forward spining out tokens.  The caller is//		responsible for makeing space for the tokens.//	The grammar for this is://	tok -> num op//	num -> [0-9.]//	op	-> [+-*/¡¼"']#include	<cstring>#include	<cstdlib>#include	<cctype>#include	"Tuple.h"const	char	EOS	=	'\0';using namespace std;// The formally classify a token string into a tuple construct//	there is a type field//	a value which represents a real number//	a func code which is the first 4 characters associated with a string.Tuple::Tuple( short typ, double val, unsigned long f ) {	type = typ;	value = val;	func	= f;	order	= 32767;	// 1/2 way to the end.}Tuple::Tuple()	{	type	= Terminal;	value	= 0.0;	func	= '    ';	order	= 32767;	// 1/2 way to the end.}Tuple::Tuple( Tuple& in ) {	type = in.type;	value = in.value;	func = in.func;	order	= 32767;	// 1/2 way to the end.}Tuple&Tuple::operator=( Tuple& in ) {	type = in.getType();	value = in.getValue();	func = in.getFunc();	return *this;}Tuple::Tuple( char* tokStr ) {	createTuple( tokStr );}Tuple::Tuple( char* tokStr, short len ) {	char cc = tokStr[len];	tokStr[len] = EOS;	createTuple( tokStr );	tokStr[len] = cc;}#include	"ArithTuple.cp"
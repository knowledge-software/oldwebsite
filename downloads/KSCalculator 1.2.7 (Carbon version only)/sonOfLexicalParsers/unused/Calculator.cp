//	Knowledge Software Consulting	© Paul Beeken, 1999  Work in Progress.//--------------------// The idea is to build a parser that will take a simple calculation expression//	and return a result.  The input is a string.  The output a string representing//	the result of the calculations.//	I impose a couple of constraints on the lexicon, parser and compiler. 1) I can't//	have linked lists.  2) the lexicon must be simple and reentrant.  3) it need only//	be left associative.////--------------------//	Parser...//		This implementation of a string translator allows the caller to track the//		position of the indicator.  It takes a pointer to a null terminated string//		or position indicator and scans forward spining out tokens.  The caller is//		responsible for makeing space for the tokens.//	The grammar for this is://	tok -> num op//	num -> [0-9.]//	op	-> [+-*/¡¼"']#include	<string.h>#include	<stdlib.h>#include	<ctype.h>#include	"LexicalParser.h"#include	<cmath>//#include	<strstream>//#define	DEBUG#ifdef DEBUG#include <iostream>using namespace std;#endif//***********//*** Function List//***********#ifdef __INTEL__const ulong SINH	=	'HNIS';const ulong ASNH	=	'HNSA';const ulong COSH	=	'HSOC';const ulong ACSH	=	'HSCA';const ulong TANH	=	'HNAT';const ulong ATNH	=	'ATNH';const ulong SIN 	=	' NIS';const ulong ASIN	=	'NISA';const ulong COS 	=	' SOC';const ulong ACOS	=	'SOCA';const ulong TAN 	=	' NAT';const ulong ATAN	=	'NATA';const ulong EXP 	=	' PXE';const ulong SQRT	=	'TRQS';const ulong LN  	=	'  NL';const ulong LOG 	=	' GOL';const ulong PI  	=	'  IP';#elseconst ulong SINH	=	'SINH';const ulong ASNH	=	'ASNH';const ulong COSH	=	'COSH';const ulong ACSH	=	'ACSH';const ulong TANH	=	'TANH';const ulong ATNH	=	'ATNH';const ulong SIN 	=	'SIN ';const ulong ASIN	=	'ASIN';const ulong COS 	=	'COS ';const ulong ACOS	=	'ACOS';const ulong TAN 	=	'TAN ';const ulong ATAN	=	'ATAN';const ulong EXP 	=	'EXP ';const ulong SQRT	=	'SQRT';const ulong LN  	=	'LN  ';const ulong LOG 	=	'LOG ';const ulong PI  	=	'PI  ';#endif//***********//*** Function List//***********//*******************************************************************//	Calculator				constructor						[public]//		Builds the inital token stream from a supplied string.//*******************************************************************Calculator::Calculator( char* inString, bool eStandard ) : lookAhead( tupArray[0] ), europeanStandard( eStandard )	{	errorMsg[0] = '\0';	// initially empty	// strip trailing spaces.	for( short i=strlen(inString)-1; i>=0 && isspace(inString[i]); i-- )		inString[i] = '\0';		tokens( inString );	}//*******************************************************************//	Execute					method							[public]//*******************************************************************voidCalculator::Execute( char* theResult )	{	errorMsg[0] = '\0';	// initially empty	if (setjmp(env) == 0) {	//try {										// no try..catch PBB						#ifdef DEBUG							DumpTuples();						#endif	parse();						#ifdef DEBUG							DumpTuples();						#endif	result();	//		} catch( char* s ) {				// no try..catch PBB	//		strcpy( errorMsg, s );				// no try..catch PBB	//					#ifdef DEBUG			// no try..catch PBB	//						DumpTuples();		// no try..catch PBB	//					#endif					// no try..catch PBB	//		}									// no try..catch PBB	}	if ( theResult != NULL )		Answer( theResult );}//*******************************************************************//	Answer			method							[public]//	Produces the result in a string form.//*******************************************************************voidCalculator::Answer( char* theResult )	{	if ( *errorMsg )		strcpy( theResult, errorMsg );	else {		double val = 	double( tupStack[stackIndex] );//		ostrstream out( theResult, 200 );//		out << double( tupStack[stackIndex] );		//		if ( europeanStandard ) { // European settings.//			long sign = copysign ( 1, val );//			double ival = floor( abs( val ) );//			long mant = roundtol( 1000000.0 * fmod( abs(val), ival ) );//			sprintf( theResult, "%ld,%ld", sign*(long)ival, mant );//			}//		else			sprintf( theResult, "%f", val );		}				}//*******************************************************************//	DumpTuples			method							[public]//	A debugging function, ordinarily unavailable.//*******************************************************************voidCalculator::DumpTuples()	{#ifdef DEBUG	cout << endl << "Tuple Array..................." << endl;	for( int i=0; tupArray[i].isnot( Terminal ); i++ ) {		cout << "\t\t tk:";		ushort typ = tupArray[i].theType();		cout.write( (char*)&typ, 2 );//		cout << "(" << tupArray[i].order << "), ";		cout << " ";		ulong fun = tupArray[i].theFunc();		if ( tupArray[i].is( Function ) )			cout.write( (char*)&fun, 4 );		else if ( tupArray[i].is( Number ) )			cout << double( tupArray[i] );//		cout << tupArray[i].order;		cout << endl;		}	cout << "......................................" << endl;#endif}//*******************************************************************//	tokens					method							[private]//		Builds the inital token stream from a supplied string.//	Create the conditioned stream.//	We can allow this in the constructor since there are no real errors here.  Any//	string will make it into the preliminray parsed array.//	We will do some preprocessing here.  For example.  A number in front//	of a parentheses or function will have an implied multiply.  We also//	distinguish the unary operations here.  //	e.g.	3 ( ...  -> 3 * (  and ) 6 -> ) * 6.//	Remember this is still part of the one pass compiler there is no tree//	generation here.  We are simply pre-processing and conditioning the//	input stream.  This is valuable since we can do some preprocessing,//	the resulting token string can then be processed without as much error//	checking on the second pass.  The preprocessor only requires at most O(K*n) operations//	where n is the number of characters and K is the number of preprocessor commands.//	The savings comes from the simplification of the actual translator.//*******************************************************************void	Calculator::tokens( char* inString )	{	char	strToken[255];	short	i = 0;			Tuple	multTuple (Multiply,0.0,'    ');	Tuple	delTuple  (DeltaOp,0.0,'    ');	inString = lexical( inString, strToken );	while( inString ) {		Tuple	token( strToken );	// These preprocessors handle the implied multiply wrt space.		if ( i>0 && token.is( Number ) && tupArray[i-1].is( Number ) )			tupArray[i++] = multTuple;		if ( i>0 && token.is( Number ) && tupArray[i-1].is( CloseParen ) )			tupArray[i++] = multTuple;	// These preprocessors handle the implied multiply wrt parenthesis.		if ( i>0 && token.is( OpenParen ) && tupArray[i-1].is( Number ) )			tupArray[i++] = multTuple;		if ( i>0 && token.is( OpenParen ) && tupArray[i-1].is( CloseParen ) )			tupArray[i++] = multTuple;	// These preprocessors handle the implied multiply wrt functions.		if ( i>0 && token.is( Function ) && tupArray[i-1].is( Number ) )			tupArray[i++] = multTuple;		if ( i>0 && token.is( Function ) && tupArray[i-1].is( CloseParen ) )			tupArray[i++] = multTuple;	// These preprocessors handle the implied addition wrt angles.	//	I have tried all manner of syntax coupling.  There is no doubt that the proper	//	processing of these tuples is best done on this initial pass thruough.	//	For example: 2* 3¡14' should resolve to 2* (3¡ + 14') which can only happen	//		if I use a special 'delta' addition tuple and another level of descent	//		in the compiler.  It is far simpler to use this pre scanner to recognize	//		sequences and pre-process the tuples.  The problem comes when I remove angle	//		tuples from the stream; I can no longer recognize the implied addition.  The	//		solution is to flag numbers that are angles.  This will allow additional 	//		processing based on that flag.  Note that under this scheme patterns like	//		(2*23)¡ are not recognized.		if ( i>1 && token.is( AngleMin ) && tupArray[i-2].is( AngleDeg ) ) {			tupArray[i] = tupArray[i-1];			tupArray[i-1] = delTuple;			i++;			}		if ( i>1 && token.is( AngleSec ) && tupArray[i-2].is( AngleDeg ) ) {			tupArray[i] = tupArray[i-1];			tupArray[i-1] = delTuple;			i++;			}		if ( i>1 && token.is( AngleSec ) && tupArray[i-2].is( AngleMin ) ) {			tupArray[i] = tupArray[i-1];			tupArray[i-1] = delTuple;			i++;			}	// These preprocessors handle unary operators.		if ( i==0 && token.is( Addition ) )			token.setType( UnaryPlus );		if ( i==0 && token.is( Subtract ) )			token.setType( UnaryNeg );		if ( i>0 && token.is( Addition ) && tupArray[i-1].isnot( Number ) && tupArray[i-1].isnot( CloseParen ) 				 && tupArray[i-1].isnot( AngleDeg ) && tupArray[i-1].isnot( AngleSec ) && tupArray[i-1].isnot( AngleMin ) )			token.setType( UnaryPlus );		if ( i>0 && token.is( Subtract ) && tupArray[i-1].isnot( Number ) && tupArray[i-1].isnot( CloseParen ) )			token.setType( UnaryNeg );		if ( token.isnot( Undefined ) )			tupArray[i++] = token;		// get next lexicon.		inString = lexical( inString, strToken );		}		// A sentinel -- are automatic by virtue of the default Tuple constructor.//	Tuple	termTuple(Terminal,0.0,'----');//	tupArray[i] = termTuple;}//*******************************************************************//	lexical					method							[private]// This is the first step in the calculator: the lexical analyzer.//	It reduces the string into smaller lexical chuncks for later tokenization.//	It starts with a pointer to a null terminated string and returns a pointer//	as to where in the string it stopped.  This is where a one pass compiler would//	also perform lookahead analysis to determine what token to assign but I want//	greater modularity.  This routine cannot really fail since all it does is collect//	lexical elements. It is intended to be completely deterministic.//// The grammar for this translator is//	tok			-> operator | string | num//	num			-> [0-9.]+//	name		-> [a-zA-Z][a-zA-Z0-9]+//	operator	-> anything else as a single character//*******************************************************************char*	Calculator::lexical( char* in, char* tokStr )	{		if ( *in == '\0' )		return NULL;	// universal signal to indicate the end of the line.		*tokStr = '\0';	// nil terminate by default		while( *in ) {		// **** Collect digits and decimals into one token.		if ( isdigit( *in ) || *in == '.' ) {	// PBB trial to see if parser can trap numbers of type: .232			// Collect all the digits including any decimal places.			while ( isdigit( *in ) || *in == '.' || *in == ',' || *in == 'E' || *in == 'e' ) { // scientific notation//				if ( europeanStandard ) { // European settings.//					if ( *in != '.' ) {	// ignore commas.  For european settings//						if ( *in == ',' ) {//							*tokStr++ = '.';//							in++;//							}//						else//							*tokStr++ = *in++;//						}//					else//						in++;//					}//				else { // American/UK settings.					if ( *in != ',' )	// ignore commas.  // Won't work in european settings!  Need to reformulate.						*tokStr++ = *in++;					else						in++;//					}				*tokStr = '\0';				}			break;	// we are done.			}		else		// **** Skip whitespace.		if ( isspace( *in ) )	{			;// Do Nothing!			}		else		// **** Collect any string started as an alpha and decimals into one token.		if ( isalpha( *in ) ) {			// Collect all the characters including any digits places.			while ( isalnum( *in ) ) {				*tokStr++ = toupper( *in++ );				*tokStr = '\0';				}			break;	// we are done.			}		else	{			// return a single token.			*tokStr++ = *in++;			*tokStr = '\0';			break;			}		// Next!		in++;		}		return in;}//*******************************************************************//	lexan					method							[private]// We wish to implement the following grammar://		Under the rules of this grammar there is a set of special high priority postfix operators//		for identifying angles.  There is a special addition operator which is coupled to this called//		the Delta operator.  Syntaxes such as 14¡13' produce streams that look like: 14 deg Æ 13 min//		whose operators should have priority over the standard aritmetic operators +,-,*, and /.//		The basis for this results in the following expectation://		2 * 14¡32'16"  -> 2 * (14¡+32'+16")  i.e. the angle components stay together.//	expr	->	expr + term//				expr - term//				¿ + term	// unary plus//				¿ - term	// unary minus//				term//	term	->	term * value//				term / value//				value//	value	->	factor ¡//				factor '//				factor "//				value Æ value	// Æ is the special incremental operator.//	factor	->	( expr )//				FUNC//				NUM [ deg // special terminals//			       || min // which modify the number.//				   || sec ]////*******************************************************************Tuple&Calculator::lexan()	{	return tupArray[inputStreamIndex++];}//*******************************************************************//	parse					method							[private]voidCalculator::parse()	{	inputStreamIndex = 0;	stackIndex = 0;	lookAhead = lexan();	while ( lookAhead.isnot( Terminal ) ) {		expr();		}}//*******************************************************************//	expr					method							[private]voidCalculator::expr()	{#ifdef DEBUG_FUNC_H	cout << "expr()...";	emit( lookAhead );	cout << endl;#endif	Tuple	t; //=lookAhead;	term();	for(;;) {		switch( lookAhead.theType() ) {			case	Addition:			case	Subtract://			case	UnaryNeg://			case	UnaryPlus:				t = lookAhead;				match( lookAhead ); 				term(); 				emit( t );				continue;			default:				return;			}		}}//*******************************************************************//	term					method							[private]voidCalculator::term()	{#ifdef DEBUG_FUNC_H	cout << "term()..." ;	emit( lookAhead );	cout << endl;#endif	Tuple t; //=lookAhead; 	value();	for(;;) {		switch( lookAhead.theType() ) {//			case	PowerOf:					//	Enter a line to be parsed: 2*10^2												//	I got Ò2*10^2Ó --> And the answer is...400.000000			case	Multiply:			case	Divide:				t = lookAhead;				match( lookAhead );				value(); 				emit( t );				continue;			default:				return;			}		}}//*******************************************************************//	value					method							[private]voidCalculator::value()	{#ifdef DEBUG_FUNC_H	cout << "value()..." ;	emit( lookAhead );	cout << endl;#endif	Tuple t; //=lookAhead;	factor();	for(;;) {		switch( lookAhead.theType() ) {			case	PowerOf:				// PBB order of precidence for ^ changed.				t = lookAhead;				//				match( PowerOf );			//				value(); 					//				emit( t );					//				continue;					//			case AngleDeg:			case AngleMin:			case AngleSec:			case Percent:				emit( lookAhead ); 				match( lookAhead );				continue;			case	DeltaOp:				t = lookAhead;				match( DeltaOp );				value();				emit( t );				continue;			case	UnaryNeg:			case	UnaryPlus:				t = lookAhead;				match( lookAhead );				value();				emit( t ); 				continue;			default:				return;			}		}}//*******************************************************************//	factor					method							[private]voidCalculator::factor()	{#ifdef DEBUG_FUNC_H	cout << "factor()..." ;	emit( lookAhead );	cout << endl;#endif	switch( lookAhead.theType() ) {		case	OpenParen:			match( OpenParen ); 			expr();			match( CloseParen ); 			break;		case	Number:			emit( lookAhead ); 			match( Number );			// special case of a number modifier.  Formally, this should be another descent in the parse tree	//		if ( lookAhead.is( AngleDeg ) || lookAhead.is( AngleMin ) || lookAhead.is( AngleSec ) ) {	//			emit( lookAhead );	//			match( lookAhead );	//		5/18/99 inserted a break in the parse tree that allows min sec and deg to be a function.	//			}			break;		case	Function:			// we should scan forward for another factor			Tuple	f = lookAhead;	// pbb			match( Function );		// pbb			match( OpenParen ); 	// pbb			expr();					// pbb			match( CloseParen ); 	// pbb			emit( f );	//	emit( lookAhead ); 						//	match( Function ); 			break;		case	UnaryNeg:		case	UnaryPlus:			break;		default:			error( "syntax error (factor)" );		}}//*******************************************************************//	match					method							[private]voidCalculator::match( unsigned short t )	{	if ( lookAhead.is( t ) )		lookAhead = lexan();	else {		ushort typ = lookAhead.theType();#ifdef DEBUG		cout << "Expected:";		cout.write( (char*)&t, 2 );		cout << " and got:";		typ = lookAhead.theType();		cout.write( (char*)&typ, 2 );		cout << "  ";#endif				//	 01234567890123456789012345678901234567890		char msg[100] = "Syntax Error: expected: -- and got: --";		msg[24] = ((char*)&t)[0];		msg[25] = ((char*)&t)[1];		msg[36] = ((char*)&typ)[0];		msg[37] = ((char*)&typ)[1];				error( msg );//		error( "syntax error (match)" );		}}//*******************************************************************//	emit					method							[private]voidCalculator::emit( Tuple t )	{#ifdef DEBUG//	t.order = stackIndex++;	cout << "\te\t tk:";	ushort typ=t.theType();	cout.write( (char*)&typ, 2 );//	cout << "(" << t.theType() << "), ";	cout << " ";	ulong fun = t.theFunc();	if ( t.is( Function ) )		cout.write( (char*)&fun, 4 );	else if ( t.is( Number ) )		cout << double( t );	cout << endl;#endif	switch( t.theType() ) {		case 	Undefined:					break;		case 	DeltaOp:	// fall through intentional		case 	Addition:					checkStack();					tupStack[ stackIndex-1 ].setValue( tupStack[ stackIndex-1 ].theValue() + tupStack[ stackIndex ].theValue() );					stackIndex--;					break;		case 	UnaryPlus:				//	tupStack[ stackIndex ].setValue( +tupStack[ stackIndex ].theValue() );					break;		case 	Subtract:					checkStack();					tupStack[ stackIndex-1 ].setValue( tupStack[ stackIndex-1 ].theValue() - tupStack[ stackIndex ].theValue() );					stackIndex--;					break;		case 	UnaryNeg:					checkStack();					tupStack[ stackIndex ].setValue( -tupStack[ stackIndex ].theValue() );					break;		case 	Multiply:					checkStack();					tupStack[ stackIndex-1 ].setValue( tupStack[ stackIndex-1 ].theValue() * tupStack[ stackIndex ].theValue() );					stackIndex--;					break;		case 	PowerOf:					checkStack();					tupStack[ stackIndex-1 ].setValue( pow(tupStack[ stackIndex-1 ].theValue(), tupStack[ stackIndex ].theValue()) );					stackIndex--;					break;		case 	Divide	:					checkStack();					tupStack[ stackIndex-1 ].setValue( tupStack[ stackIndex-1 ].theValue() / tupStack[ stackIndex ].theValue() );					stackIndex--;					break;		case 	Function:					// operate based on the function's name.					checkStack();					switch( t.theFunc() ) {						// Hyperbolics						case SINH :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( sinh( tupStack[ stackIndex ].theValue() ) );							break;						case ASNH :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( asinh( tupStack[ stackIndex ].theValue() ) );							break;						case COSH :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( cosh( tupStack[ stackIndex ].theValue() ) );							break;						case ACSH :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( acosh( tupStack[ stackIndex ].theValue() ) );							break;						case TANH :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( tanh( tupStack[ stackIndex ].theValue() ) );							break;						case ATNH :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( atanh( tupStack[ stackIndex ].theValue() ) );							break;						// Trig Functions						case SIN  :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( sin( tupStack[ stackIndex ].theValue() ) );							break;						case ASIN :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( asin( tupStack[ stackIndex ].theValue() ) );							break;						case COS  :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( cos( tupStack[ stackIndex ].theValue() ) );							break;						case ACOS :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( acos( tupStack[ stackIndex ].theValue() ) );							break;						case TAN  :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( tan( tupStack[ stackIndex ].theValue() ) );							break;						case ATAN :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( atan( tupStack[ stackIndex ].theValue() ) );							break;						// Exp functions						case EXP  :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( exp( tupStack[ stackIndex ].theValue() ) );							break;						case SQRT :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( sqrt( tupStack[ stackIndex ].theValue() ) );							break;						case LN   :	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( log( tupStack[ stackIndex ].theValue() ) );							break;						case LOG:	//tupStack[ ++stackIndex ] = t;							tupStack[ stackIndex ].setValue( log10( tupStack[ stackIndex ].theValue() ) );							break;						case PI:							tupStack[ stackIndex ].setValue( 3.14159265359*tupStack[ stackIndex ].theValue() );							break;						default:										error( "Unrecogized function." );						}					break;		case 	Number	:					tupStack[ ++stackIndex ] = t;					break;		case 	AngleDeg:					tupStack[ stackIndex ].setValue( tupStack[ stackIndex ].theValue()/57.2957795131 );					break;		case 	AngleMin:					tupStack[ stackIndex ].setValue( tupStack[ stackIndex ].theValue()/(60*57.2957795131) );					break;		case 	AngleSec:					tupStack[ stackIndex ].setValue( tupStack[ stackIndex ].theValue()/(60*60*57.2957795131) );					break;		case 	Percent:					tupStack[ stackIndex ].setValue( tupStack[ stackIndex ].theValue()/100. );					break;		case 	OpenParen:	// Never happens		case 	CloseParen:	// Never happens but should // flags function execution		case 	Initial	:	// Never happens		case 	Terminal:	// Should never happen.					break;		default:					;		}}//*******************************************************************//	result					method							[private]TupleCalculator::result()	{	Tuple t = tupStack[stackIndex];#ifdef DEBUG//	t.order = stackIndex++;	cout << "\t\t result:";	ushort typ = t.theType();	cout.write( (char*)&typ, 2 );//	cout << "(" << t.theType() << "), ";	cout << " ";	ulong	fun = t.theFunc();	if ( t.is( Function ) )		cout.write( (char*)&fun, 4 );	else if ( t.is( Number ) )		cout << double( t );	cout << endl;#endif	return t;}//*******************************************************************//	checkStack				method							[private]voidCalculator::checkStack()	{	if ( stackIndex < 0 )		error( "stack underflow" );	if ( stackIndex > kTupStackSize )		error( "stack overflow" );	return;}voidCalculator::error( char* s )	{//	throw s; 	strcpy( errorMsg, s );	longjmp(env, 1); }
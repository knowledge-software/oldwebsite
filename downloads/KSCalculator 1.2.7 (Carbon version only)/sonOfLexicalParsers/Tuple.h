#pragma once//	Knowledge Software Consulting	© Paul Beeken, 1999  Work in Progress.//--------------------// The idea is to build a parser that will take a simple calculation expression//	and return a result.  The input is a string.  The output a string representing//	the result of the calculations.//	I impose a couple of constraints on the lexicon, parser and compiler. 1) I don't//	want linked lists.  2) the lexicon must be simple.  3) it need only//	be left associative.//	It should be obvious to anyone familiar with parsing that I got alot of help from//	the "Dragon Book", Thanks guys.  //--------------------//	Parser...//		This implementation of a string translator allows the caller to track the//		position of the indicator.  It takes a pointer to a null terminated string//		or position indicator and scans forward spining out tokens.  The caller is//		responsible for makeing space for the tokens.//	The grammar for this is://	tok -> num op//	num -> [0-9.]//	op	-> [+-*/¡¼"']typedef	unsigned short	UShrt;typedef	unsigned long	ULong;typedef	double			Float;// Basic tuple typesenum	{	Undefined	= '00',	Initial		= 'i-',	// I don't use this sentinel	Terminal	= '-z'	};#include	"ArithTuple.h"// This defines the Abstract Tuple Object which is what the parsre ejects//// This is the object that holds the reduced token for processing into productions.//class	Tuple	{	public:		Tuple();		Tuple( char* tokStr );		Tuple( char* tokStr, short len );		Tuple( short typ, Float val=0.0, unsigned long func='    ' );				// Copy Constructors		Tuple( Tuple& in );		Tuple&	operator=( Tuple& in );				// Classic test operations.		bool	is( UShrt t )				{ return type == t; }		bool	isnot( UShrt t )			{ return type != t; }				ULong	getFunc()					{ return func; }		UShrt	getType()					{ return type; }		Float	getValue()					{ return value; }		void	setType( UShrt t )			{ type = t; }		void	setValue( Float v )			{ value = v; }		void	setFunc( ULong f )			{ func = f; }			operator	Float()				{ return value; }//		static	void	loadOperators( char[] ops );//		static	void	loadFunctions( char*[] funcList );	protected:		virtual	ULong	hash( char* str );		virtual	void	createTuple( char* str );	private:		UShrt	type;		Float	value;		ULong	func;		UShrt	order;};
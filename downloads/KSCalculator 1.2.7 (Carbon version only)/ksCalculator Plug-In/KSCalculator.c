/*:::::::::::::::::::::::::::::   Includes   ::::::::::::::::::::::::::::::*/#if __INTEL__	#include	<windef.h>	#include	<winbase.h>	#include	<winnls.h>#else	#include 	<Script.h>	#include	<Sound.h>#endif#include	<cstdio>#include	<cstring>#include	<cstdlib>#include	"FMExtern.h"#include	"KSCalculator.h"#include	"Calculator.h"void	setReturnParameter( FHandle result, long value );short	isEuropeanSystem();/*:::::::::::::::::::::::::::   function defs   ::::::::::::::::::::::::::::*/static short		gIsEuropeanSystem;short isEuropeanSystem(){#if FM_CPU_X86//	char	locale[30];//	short len = 0;//	len = GetLocaleInfo( LOCALE_SYSTEM_DEFAULT, LOCALE_SMONDECIMALSEP, locale, 30 ); //	if ( len > 0 )//		return locale[0] == ',';	return 0;#else//	Intl0Hndl ih = (Intl0Hndl) GetIntlResource(0);//	return (**ih).decimalPt == ',';	return 0;#endif}/** *	Here we enquire as to the available file services.  This is where we acccept *	or reject a request to go on-line.*/int StartUpServices(void)	{	gIsEuropeanSystem = isEuropeanSystem();#if FM_CPU_X86#else//	if ( gIsEuropeanSystem )//		SysBeep(1);#endif	/* Let's fail if some file services are not available. */	// A gestalt call is approprate here.	return 0 ? kFailLoading : kSuccessLoading;}/** *	This routine is called at shut down to allow us to remove some action. *	Unused.*/void ShutDownServices(void) {}/** *	This routine is called periodically and asynchronously to perform some update. *	Unused.*/void IdleServices(void) {}#pragma mark	-#pragma	mark	===== Utilities =====/** *	Ubiquitous return routine to code return value.*/void	setReturnParameter( FHandle result, long value ) {	FChar	errString[64];//#pragma unused (value, errString, result)		std::sprintf( (char *)errString, "@%d", value );		/* Set the result to the single character */	FMX_SetHandleSize(result, std::strlen( (char *)errString ) );	if (FMX_MemoryError() == 0) {		FMX_LockHandle(result);		std::memcpy( *result, errString, std::strlen( (char *)errString ) );		FMX_UnlockHandle(result);		}}#pragma mark -#pragma	mark	===== Actions =====/** *	Canonize an input coordinate number.  A Coordinate number can *	have one of three forms: *		DDD[¡] MM' SS"	where the ' and " are essential for triggering  *			the identity of the minutes and seconds. *		DDD[¡] MM.mmmm[']	where the ' is required to triger the identity *			of the decimal minutes. *		DDD.dddd[¡] *	The output is a decimal number between 0 and 360 which is the decimal representation *	for the coordinate*/void Calculate( FHandle parameter, FHandle result ) {	long			hdlsize, err=0L;	FChar			inputString[255];	FChar			outputString[255];/* Only do something if we got something in the parameter */	hdlsize = FMX_GetHandleSize( parameter );	if ( hdlsize > 0 && hdlsize <255 ) {		std::memcpy (inputString, (*parameter), hdlsize);		inputString[hdlsize] = '\0';		calculator((char *)inputString, (char *)outputString );				FMX_SetHandleSize(result, std::strlen( (char *)outputString ) );		if (FMX_MemoryError() == 0) {			FMX_LockHandle(result);			std::memcpy( *result, outputString, std::strlen( (char *)outputString ) );			FMX_UnlockHandle(result);			return;			}				}	setReturnParameter( result, err );}
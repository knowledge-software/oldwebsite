property gHTMLfileAlias : "SampleTable.html"property gRecordCount : 0property gFileMakerTableAlias : "The FileMaker Database Table" -- ultimately stores the alias to the FMP table.(*********** UTILITIES ****************************)on todaysDate()	-- this statement requires my custom osax strftime.  You can substitute your own tool here.	return strftime "%m/%d/%Y"end todaysDate(********** END UTILITIES *****************************)(*********** FILEMAKER SECTION *****************************)---- Return the process for this running script.on getTheDatabaseFile()	tell application "Finder"		if class of gFileMakerTableAlias is string or not (gFileMakerTableAlias exists) then			choose file with prompt "Please find the " & gFileMakerTableAlias & " file." of type "FMP3"			set gFileMakerTableAlias to the result		end if		return gFileMakerTableAlias	end tellend getTheDatabaseFile---- FileMaker Controlson openFileMakerDatabase()	--	-- Find the container folder	if false then -- don't do anything for this demo		tell application "Finder"			open my getTheDatabaseFile()		end tell	end if -- don't do anything for this demoend openFileMakerDatabase---- Place a value into a field, use a list for repeating fields.on putValuesInField(cN, cV)	if false then -- don't do anything for this demo		global rID		tell application "FileMaker Pro"			tell the current record of the front database				--log cN & "<-" & cV				copy cV to cell cN			end tell		end tell	else		log cN & " <- " & cV	end if -- don't do anything for this demoend putValuesInField---- Make a new record.on makeNewRecord()	if false then -- don't do anything for this demo		global rID		tell application "FileMaker Pro"			tell the front database				create new record				set rID to the result				go to rID			end tell		end tell	else		log "еееееееее New Record ееееееееееееее"	end if -- don't do anything for this demoend makeNewRecord(*********** END FILEMAKER SECTION *****************************)(*********** TEXT FILE HANDLING *****************************)---- Generic replace function that will eliminate extraneous characters.on replace_chars(this_text, search_string, replacement_string)	set AppleScript's text item delimiters to the search_string	set the item_list to every text item of this_text	set AppleScript's text item delimiters to the replacement_string	set this_text to the item_list as string	set AppleScript's text item delimiters to ""	return this_textend replace_chars---- Open a text file given the referenceon openFile(fn)	--	global gBytesRead  -- set to 0 if you want to track the number of read bytes.	open for access fn	set gHTMLfileAlias to the resultend openFile---- Close a file that hase been opened.on closeFile()	close access gHTMLfileAliasend closeFile---- Special quit handler to make sure the file was closed.on quit	closeFile()	continue quitend quit---- Get a string of characters from the input stream.--	Speacial notes.  I can't get the applescript use delimiers alternate to --	work as advertised.  I must scan for the start of an HTML lexicon.  I know--	that since the HTML will not allow stray "<" to appear this is fairly safe.--	data that has a "<" will be coded with a &lt. only HTML lexicons start with "<"on getStream()	--	global gBytesRead		read gHTMLfileAlias before "<" --, ">"}	set str to replace_chars(the result, return, "") -- strip returns		--	set gBytesRead to gBytesRead + (length of str)	-- use this if you want to track the number of characters.			set AppleScript's text item delimiters to ">"	set tok to every text item of str --as text items	set AppleScript's text item delimiters to ""		-- item 1 of tok is the HTML tag, item 2 is any text that follows.	return tokend getStream(*********** END TEXT FILE HANDLING *****************************)(*********** PARSING *****************************)---- Send the information to a databaseon distributeData(fieldList)	--	-- Here you can do some post processing on the values of the field.	putValuesInField("Field1", item 1 of fieldList)	putValuesInField("Field2", item 2 of fieldList)	putValuesInField("Field3", item 3 of fieldList)	putValuesInField("Field4", item 4 of fieldList)	end distributeData---- Collect all the information in for a given cellon getFieldData(val)		--	--	loop for all values	repeat while true		set tok to getStream()				-- Is it the end of the row?		if item 1 of tok starts with "/TD" then			--	exit			exit repeat		end if				-- accumulate		set val to val & item 2 of tok			end repeat	return valend getFieldData---- Loop for the individual field elements within a TABLE's row.on getRecordData()		set gRecordCount to gRecordCount + 1	--log gRecordCount		makeNewRecord()	set fieldList to {}		--	--	loop for all columns	repeat while true		set tok to getStream()		-- Is it the end of the row?		if item 1 of tok is "/TR" then			--	exit			exit repeat		end if				--		-- Valid entries start after the 4th row.		if item 1 of tok starts with "TD" then ┬			set fieldList to fieldList & getFieldData(item 2 of tok)	end repeat		distributeData(fieldList)	end getRecordData---- Loop for each TABLE's row--	Special Note: Since we are presuming a posted HTML it is well formed.--		which means we assume that all TABLE tags are closed.on loopForRecords()	activate -- I run much faster in foreground	--	-- Loop for all rows.	repeat while true		set tok to getStream()				-- Is it the end of the table?		if item 1 of tok is "/TABLE" then			--	Exit			exit repeat		end if				-- Is it the start of a row?		if item 1 of tok starts with "TR" then			getRecordData()		end if			end repeatend loopForRecords(*********** END PARSING *****************************)(*********** ENTRY POINT *****************************)---- Main entry point on processTheHTMLFile(gHTMLfileAlias)	set AppleScript's text item delimiters to ""	set gRecordCount to 0	set tableCount to 0	set isHTMLDocument to -200		-- Open the file	openFile(gHTMLfileAlias)		try		repeat while true			set tok to getStream()						--			-- Yep we got an HTML document			if item 1 of tok starts with "HTML" then ┬				set isHTMLDocument to 0						--			-- end of file			if item 1 of tok starts with "/HTML" then ┬				exit repeat			--			-- If we get this far without an "HTML" statement something is wrong.			if isHTMLDocument is -1 then ┬				error "I don't think this is an HTML document"						--			-- Found a TABLE reference			if item 1 of tok starts with "TABLE" then				--				-- The data table is after the second 1 the second table.				loopForRecords()			end if						--			-- Bump the count			set isHTMLDocument to isHTMLDocument + 1		end repeat	on error m number n		-- exclude end of file error.		if n is not -39 then ┬			display dialog "[" & n & "] " & m buttons {"Ok"} default button 1 with icon stop	end try		-- Close the file.	closeFile()end processTheHTMLFile---- Run Handleron run	--display dialog "Please drop the html file downloaded from bay area rentals on me." buttons {"Ok"} default button 1 with icon note	try		choose file with prompt "Please locate the HTML file." of type "TEXT"		set gHTMLfileAlias to the result		openFileMakerDatabase()		processTheHTMLFile(gHTMLfileAlias)	on error	end tryend run---- Drop handler.on open (lst)	set firstTime to true	repeat with f in lst		set approveFile to false		tell application "Finder"			set approveFile to (f's file type is "TEXT") and ((f's name ends with "html") or (f's name ends with "htm"))		end tell		if approveFile then			if firstTime then				openFileMakerDatabase()				set firstTime to false			end if			processTheHTMLFile(f)		end if	end repeatend open
//	© Paul B. Beeken, Work In Progress, 1994-5//	Knowledge Software Consulting.////	These files are a mindlessly simple wrapper class for the//	basic XCMD operations.  Only one instance of the xcmdBase class is//	generated per XCMD call but there may be many instances of the XCMDString//	class.  I have used these classes to whip out XCMD/XFCNs within hours of//	receiving the specs.  They work great for me but I will always consider //	suggestions.////	Please, please, please, in the unlikely event you should use this stuff//	for some commercial application I would appreciate you contacting me.  If//	its for your own use, use away. Send email: knowsoft@ios.com////	As always: this file is presented as is with no warrantees expressed or implied.//	Swim at your own risk, etc. etc.#include "xcmdWind.h"#pragma mark • Creation and Destruction…xcmdWindow::xcmdWindow( XCmdPtr xP, Boolean lockParameters ) : 	xcmdBase( xP, lockParameters )	 // set up xcmdBase and continue...{	if ( nParams() < 0 ) {	// This entry involves an "event"		xEventInfo	= XWEventInfoPtr( (*this)[0] );		// Get ext param block		xEvent		= xEventInfo->event;				// Copy eventRecord		xWindow		= (CWindowPtr)xEventInfo->eventWindow; // We are always color		xPrivStore	= (Handle)GetWRefCon( (WindowPtr)getXWindow() );		GetPort( &oldXPort );							// keep old port and...		SetPort( (WindowPtr)xWindow );					// Setup new one.		passMsg( true );	// the buck doesn't stop here		}			else {					// plain jane call.		xEventInfo	= nil;		xPrivStore	= nil;		oldXPort	= nil;		xWindow		= nil;		}}xcmdWindow::~xcmdWindow(){	if ( getXWindow() )		// We have a valid windowPtr so we should update		SetWRefCon( (WindowPtr)getXWindow(), (long)xPrivStore ); // We may have changed the handle.	if ( isWindowEvent() )	// We were called through an "event" 		SetPort( oldXPort );				// restore old environment}#pragma mark	-#pragma mark	• Make New WIndows…CWindowPtrxcmdWindow::createWindow( short rID, ResType rType, Boolean flot ){	// get from a template.  (always a color window)	return xWindow = (CWindowPtr) 		::GetNewXWindow( theParamPtr(), rType, rID, true, flot );	// don't do drawing here.  You'll get an event.}CWindowPtrxcmdWindow::createWindow( Rect& r, xcmdString& title, short procID, Boolean vis, Boolean flot ){	// create from description.  (always a color window)	return xWindow = (CWindowPtr) 		::NewXWindow( theParamPtr(), &r, StringPtr(title), vis, procID, true, flot );	// don't do drawing here.  You'll get an event.}voidxcmdWindow::idleTime( long ticks ){	// a subtle trick to determine if we have received the xOpenEvt.	// any call outside the scope of this object would have a null XWEventInfo*	if ( xEventInfo && xWindow )		SetXWIdleTime( theParamPtr(), (WindowPtr)xWindow, ticks );}#pragma mark	-#pragma mark	• Event Bottleneck…voidxcmdWindow::doWindowEvent( void ){	if ( !isWindowEvent() ) return;	Point     p = xEvent.where;	switch( xEvent.what ) {		case xOpenEvt:			/* the first event after you are created */				doOpenWindow();				break;		case xCloseEvt:			/* your window is being forced close (Quit?) */				doCloseWindow();				break;		// We only get these calls if we made some special call to a call back.		case xGiveUpEditEvt:	/* you are losing Edit... */		case xEditUndo:			/* Edit——Undo */		case xEditCut:			/* Edit——Cut */		case xEditCopy:			/* Edit——Copy */		case xEditPaste:		/* Edit——Paste */		case xEditClear:		/* Edit——Clear */				doEditEvent( xEvent.what );				break;		//case xGiveUpSoundEvt:	/* you are losing the sound channel... */				// homey don't play this.		case xMBarClickedEvt:	/* a menu is about to be shown--update if needed */				doMenuUpdate();				break;		case xMenuEvt:			/* user has selected an item in your menu */				doMenuClick( long( getXEventParam(1) ), long( getXEventParam(2) ) );				break;						// These are not documented well.		case xHidePalettesEvt:	/* someone called HideHCPalettes */		case xShowPalettesEvt:	/* someone called ShowHCPalettes */				doShowHide( (xEvent.what==xShowPalettesEvt) );				passMsg( false );				break;		case xSendEvt:			/* script has sent you a message (text) */				doMessage( StringPtr( getXEventParam(0) ) );				break;		case xSetPropEvt:		/* set a window property */				doSetProperty( StringPtr( getXEventParam(0) ), Handle( getXEventParam(1) ) );				break;		case xGetPropEvt:		/* get a window property */				xcmdString*	rc;				rc = doGetProperty( StringPtr( getXEventParam(0) ) );				setXEventResult( rc );				delete rc;				break;		case xCursorWithin:		/* cursor is within the window */				doCursorWithin();				break;// The standard toolbox events		case keyDown:		case autoKey:			doKeyDown( xEvent.message & charCodeMask, xEvent.modifiers );			break;		case mouseDown:			WindowPtr w;			short	part	= 	FindWindow(p, &w);			switch ( part ) {	// snatch mousedowns in buttons				case inGrow:					Rect r;					SetRect(&r, 80, 80, 600, 380);					long sze = GrowWindow(w, p, &r);					::InvalRect( &(w->portRect) );  // force a redraw.					SizeWindow(w, LoWord(sze), HiWord(sze), true);					passMsg( false );					break;				default:					doMouseDown( part );			}		case nullEvent:			/* only gets called if we have "interupt" code */				doIdleStuff();				break;		case activateEvt:		/* window is bcoming active */				doActiveWindow( xEvent.modifiers & activeFlag );				break;		case updateEvt:				doUpdateWindow();				passMsg( false );				break;		case app4Evt:			/* suspend/resume */				doShowHide( (xEvent.message % 2 != 0) );				passMsg( false );				break;		} // switch}#pragma mark	-#pragma mark	• Event Actions…voidxcmdWindow::doActiveWindow( Boolean activating ){		// an activate/deactivate event.	if ( activating ) {		; // do some activating	} else {		; // do some deactivating	}}voidxcmdWindow::doShowHide( Boolean showFlag ){	// Handle events relating to app4Evt.  showFlag ? visible : invisible	ShowHide( (WindowPtr)getXWindow(), showFlag );}voidxcmdWindow::doUpdateWindow( void ){	::BeginUpdate((WindowPtr)getXWindow());			doDrawWindow();					::EndUpdate((WindowPtr)getXWindow());}// These are the default actions for the window. most do nothing.voidxcmdWindow::doOpenWindow( int show ){		// Window is openning, initialize	// Show it if it is hidden.	ShowHide( (WindowPtr)getXWindow(), show );	}voidxcmdWindow::doCloseWindow( void ){	// Window is closing, clean up	passMsg( true ); // go ahead, close it.}voidxcmdWindow::doEditEvent( short what ){	// Handle events relating to editing.	switch( what ) {			case xGiveUpEditEvt:	/* you are losing Edit... */			case xEditUndo:			/* Edit——Undo */			case xEditCut:			/* Edit——Cut */			case xEditCopy:			/* Edit——Copy */			case xEditPaste:		/* Edit——Paste */			case xEditClear:		/* Edit——Clear */			;		}}voidxcmdWindow::doKeyDown( char keyChar, unsigned short mod ){	// We only get key down events if we register as a text editing environment}voidxcmdWindow::doMenuUpdate( void ){	// A menuBar click, set up menus}voidxcmdWindow::doMenuClick( long m, long i ){	// A menu click}		voidxcmdWindow::doMessage( const xcmdString& msg ){	// a send message to window...}voidxcmdWindow::doDrawWindow( void ){	// do some drawing.}		voidxcmdWindow::doSetProperty( const xcmdString& prop, const xcmdString& val ){	// set a window property	// let hypercard handle it		passMsg( true );}xcmdString*xcmdWindow::doGetProperty( const xcmdString& prop ){	// get a window property	// If you handle this property you create a new xcmdString* set its	//	value and return the pointer.  The caller will destroy it.	passMsg( true );	// let hypercard handle it	return nil;			// I didn't handle this!}voidxcmdWindow::doCursorWithin( void ){	// cursor is within the window */	passMsg( false );  // let hypercard handle it}voidxcmdWindow::doMouseDown( short part ){	}voidxcmdWindow::doIdleStuff( void ){	// This will only get called if we call idleTime with nonzero number.}#pragma mark	-#pragma mark	• Accessors…		// These functions must be used with great care.		// I don't check to see if the xEvent pointer is valid.CWindowPtrxcmdWindow::getXWindow( void ){	return xWindow;}void*xcmdWindow::getXEventParam( int i ){	return (void*) xEventInfo->eventParams[i];}voidxcmdWindow::setXEventResult( xcmdString* rv ){	if ( rv ) 		xEventInfo->eventResult = Handle(*rv);	else		xEventInfo->eventResult = nil;  // nil}EventRecord*xcmdWindow::getXEvent( void ){	return &xEvent;}#pragma mark	-#pragma mark	• Protected…voidxcmdWindow::beginEdit( void ){	BeginXWEdit( theParamPtr(), (WindowPtr)xWindow );}voidxcmdWindow::endEdit( void ){	EndXWEdit( theParamPtr(), (WindowPtr)xWindow );}voidxcmdWindow::allowReEntrancy( Boolean sysEvt, Boolean hcEvt ){	// a subtle trick to determine if we have received the xOpenEvt.	// any call outside the scope of this object would have a null XWEventInfo*	if ( xEventInfo && xWindow )		XWAllowReEntrancy( theParamPtr(), (WindowPtr)xWindow, sysEvt, hcEvt );}voidxcmdWindow::hasInteruptCode( Boolean hasIcode ){	// a subtle trick to determine if we have received the xOpenEvt.	// any call outside the scope of this object would have a null XWEventInfo*	if ( xEventInfo && xWindow )		XWHasInterruptCode( theParamPtr(), (WindowPtr)xWindow, hasIcode );	// suggestion, call "alwaysMoveHigh" right after creation of the window	//	that way, when you get the xOpenEvt you can lock the code and it will	//	be high in the stack.}voidxcmdWindow::alwaysMoveHigh( Boolean doIt ){	XWAlwaysMoveHigh( theParamPtr(), (WindowPtr)xWindow, doIt );}voidxcmdWindow::close( void ){	// close me (rarely used, let hc do it.)	if ( xWindow )		CloseXWindow( theParamPtr(), (WindowPtr)xWindow );}shortxcmdWindow::registerMenu( Boolean reg, short mResID ){	// give me a mResID and I'll create a unique id and hand it to you	if ( reg ) {		MenuRef mr = GetMenu( mResID );		if ( !mr ) return 0;  // invalid ID		// find a unique ID.		mResID = 1023;		MenuRef	menu;		do {			menu = GetMenuHandle( ++mResID );			} while ( menu );					RegisterXWMenu( theParamPtr(), (WindowPtr)xWindow, mr, true );		return mResID;		}			// you are giving me a menuID.  I'll un-register the menu	else {		MenuRef	mr = GetMenuHandle( mResID );		RegisterXWMenu( theParamPtr(), (WindowPtr)xWindow, mr, false );		return 0;		}}
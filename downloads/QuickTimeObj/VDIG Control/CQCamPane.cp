// ===========================================================================//	CQCamPane.cp					A pane using the newly created CQuickCam obj// ===========================================================================//	See © notices in CQuickCam.*//	12/02/95	Finsihed CQuickCam enought to try this out.//	12/20/95	This is a mindlessly simple implementation and test bead for the //			CQuickCam class.  This class contains the features needed to control//			the vdig component.  Inititally these two classes, CQuickCam and LPane//			were combined to form one class.  This separation allowed the development//			of video input panes dependant on other vdig components. #include	"CQCamPane.h"#include	<LStream.h>// ---------------------------------------------------------------------------//		¥ Constant declarations// ---------------------------------------------------------------------------#pragma mark ¥ Constructors/Destructors// ---------------------------------------------------------------------------//		¥ CreateGraphPane// ---------------------------------------------------------------------------//	Static constructor used in URegistrarCGrabPane*CGrabPane::CreateGrabPaneStream( LStream* inStream ){	return	(new CGrabPane(inStream) );}CGrabPane::CGrabPane( LStream* inStream )	: LPane( inStream ), CVDig( 'CQCm', 'Ctx7' ){	grabPict = nil;}CGrabPane::CGrabPane( void ) : CVDig( 'CQCm', 'Ctx7' ){	grabPict = nil;}CGrabPane::~CGrabPane( void ){	StopRepeating();	if ( grabPict ) KillPicture( grabPict );}#pragma mark -#pragma mark ¥ LPeriodical overridevoid	CGrabPane::SpendTime(const EventRecord &inMacEvent){	if ( IsVisible() ) {		Rect	paneFrame;		CalcPortFrameRect( paneFrame );					UpdateVideo();//		DrawVideo( (CGrafPtr)GetMacPort(), paneFrame );		}}#pragma mark -#pragma mark ¥ LPane overridesvoidCGrabPane::DrawSelf(){	Rect	paneFrame;	CalcPortFrameRect( paneFrame );		// Set the videoFrame to an appropriate size.	try {		PlayThrough( GetMacPort(), paneFrame );//		OptVideoRect( paneFrame );		}	catch( OSErr rc ) {		StopRepeating();		}	// I don't actually draw anything here since it is done at 	//	Repeat time.	}voidCGrabPane::ClickSelf(const SMouseDownEvent &inMouseDown){	Rect	paneFrame, spotFrame;			CalcPortFrameRect( paneFrame );	spotFrame = paneFrame;		::InsetRect( &spotFrame, 30, 30 );	for( int i = 6; --i; )	{ // do it for about n passes.		SpotMeter( spotFrame );		UpdateVideo();		DrawVideo( (CGrafPtr)GetMacPort(), paneFrame );				{			Str255	theCount;		::MoveTo( spotFrame.right, spotFrame.bottom );		::PenMode( srcXor );		::NumToString( i, theCount );		::DrawString( theCount );		::FrameRect( &spotFrame );		}				}		}////	Fire up the sequencer.voidCGrabPane::FinishCreateSelf(){	StartRepeating();}#pragma mark -#pragma mark ¥ Public methods#pragma mark -#pragma mark ¥ Protected methods#pragma mark -#pragma mark ¥ Private Methods
#pragma once//	© Paul B. Beeken, Work In Progress, 1994-5//	Knowledge Software Consulting.////	Please, please, please, in the unlikely event you should use this stuff//	for some commercial application I would appreciate you contacting me.  If//	its for your own use, use away. Send email: knowsoft@idt.net//	My personal philosophy closely adheres to that of GNU software.  I offer this//	in the hope that others will improve and expand upon it.  Post your additions,//	leave this notice in place and add your own comments.////	As always: this file is presented as is with no warrantees expressed or implied.//	Swim at your own risk, etc. etc.////	CVDig.cp////	A c++ object library for the Quicktime component library of the VDIG component.//	This should provide a nice superclass for special vdig subclasses.////	Notes in general:  There are sometimes many ways to handle the //		output of a vdig.  It can preview directly to the screen (if it is//		a cGrafPort and the vdig 'doesDMA') or to a pixmap if it does not.//		Multiple buffering is an option and can be a very effective method//		for rapid capturing and preview needs.  It can allow the greatest//		flexability.  This object allows for any of these options subject to//		to the constraint provied by the vdig code.////	Current version 1.0		© Paul B. Beeken, Knowledge Software Consulting.////	Sat, Sep 21, 1996 10:23:41 PM	Begin consruction of vdig object.//#include	<quicktimeComponents.h>class	CVDig	{	public:		CVDig( OSType subType=0L, OSType manufacturer=0L );		~CVDig( void );		// Controls on the analog video signal -> digImage		Rect	CaptureRectangle( void );		void	CaptureRectangle( Rect r );		// Play through to a grafPort.		void			PlayThrough( GrafPtr window, Rect& rectInWindow );		void			SetMode( Boolean color, short depth );			// optimize a rectangle for best viewing.		Rect			BestVideoRect( const Rect& r );		Rect			OptVideoRect( const Rect& r );	// sets vdig rect to optimal size for given Rect.			// Choose the input source		void			InputSource( short src );		short			InputSource( void );																// returns it for use by caller.			// Get and set the contrast.		void			Contrast( unsigned short v );		unsigned short	Contrast( void );			// Get and set the brighness.		void			Brightness( unsigned short v );		unsigned short	Brightness( void );		// These methods control the digitizer.			// update the video buffer.		void			UpdateVideo( void );			// draw the of the last filled buffer to a rect within the given port		void			DrawVideo( CGrafPtr gw, const Rect& r );		void			SpotMeter( unsigned short b );	// Set target brightness		void			SpotMeter( const Rect& r );		// Spot meter in r			// Set the state of the input field:		void			flipHorizontal( Boolean flip );	// flip it.		Boolean			flipHorizontal( void );			// horiz flip state		void			flipVertical( Boolean flip );	// flip it.		Boolean			flipVertical( void );			// vert flip state			// Set default video characteristics		void			SetDefaults( void );			// Grab a pict.		PicHandle		GrabPict( void );			// We need to be able to instantiate and add sequences to a moov file.			//		to be continued...			// Return the current InfoRecord.		DigitizerInfo	GetInfoRecord( void );	protected:		virtual	void			CreateGWorld( Rect& r );		virtual void			DestroyGWorld( void );		virtual	void			CreateBuffers( short n=1 );		virtual void			DestroyBuffers( void );				void			UpdateFlags( void );				Rect					videoFrame;		// frame to digitize. (INPUT)		MatrixRecord			videoMatrix;	// transformation matrix.		RgnHandle				videoMask;				// There be dragons beyond here.  Don't mess with these.	private:		VideoDigitizerComponent	vdig;			// Instance of a vdig		DigitizerInfo			vdigInfo;		// Information		Rect					vdigMaxRect;	// Largest digitizing rect		unsigned short			vdigBlackLevel;		unsigned short			vdigWhiteLevel;		unsigned short			vdigBrightness;		unsigned short			vdigHue;		unsigned short			vdigSaturation;		unsigned short			vdigContrast;		unsigned short			vdigSharpness;			short					vdigInputs;		// max allowable input index.				short					digiDepth;		short					digiMode;		// 1 for Color, 0 for B&W		short					bufferCount;		short					bufferIndex;				GWorldPtr				gWorld;			// gWorld for capture (could be current port)		float					bright;			Boolean					hFlip;		Boolean					vFlip;	};
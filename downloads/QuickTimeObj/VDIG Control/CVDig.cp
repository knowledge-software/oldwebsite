//	© Paul B. Beeken, Work In Progress, 1994-5//	Knowledge Software Consulting.////	Please, please, please, in the unlikely event you should use this stuff//	for some commercial application I would appreciate you contacting me.  If//	its for your own use, use away. Send email: knowsoft@idt.net//	My personal philosophy closely adheres to that of GNU software.  I offer this//	in the hope that others will improve and expand upon it.  Post your additions,//	leave this notice in place and add your own comments.////	As always: this file is presented as is with no warrantees expressed or implied.//	Swim at your own risk, etc. etc.////	CVDig.cp////	A c++ object library for the Quicktime component library of the VDIG component.//	This should provide a nice superclass for special vdig subclasses.////	Notes in general:  There are essentially 3 different ways to handle vdig output//		1) Direct write to screen without buffering.  This mode has two solutions://			HWWriteThru which, if the vdig supports this option writes directly to the//			screen asynchronously to any loop.  This, if supported, is the best possible option.//			Another is where the vdig writes to the screen but needs some kind of Grab command//			at idle time.//There are sometimes many ways to handle the //		output of a vdig.  It can preview directly to the screen (if it is//		a cGrafPort) or to a pixmap.  Multiple buffering is an option and//		can be a very effective method given the serial data stream nature of //		this kind of digitizer.  It can allow the greatest flexability//		and smoothness of updating.  It may not be the best solution for a//		particular application.//////	Current version 1.0		© Paul B. Beeken, Knowledge Software Consulting.////	Mon, Sep 24, 1996 09:24:16 AM	All exceptions are typed as: ComponentResult, instead of mixing//	Sat, Sep 21, 1996 10:23:41 PM	Begin consruction of vdig object.//#include	"CVDig.h"#include	<limits.h>#pragma mark	¥ Creation and Destruction operators//	Creation routine.CVDig::CVDig( OSType subType, OSType manufacturer ){	// Check to see if we have the right QT version.	long	response;	OSErr rc = Gestalt( gestaltQuickTimeVersion, &response );	if ( rc != 0 ) throw rc;	// most likely QT isn't present	if ( ( response & 0xFFFF ) < 0x200 ) throw gestaltUnknownErr;	// Same result if its version isn't >= 2.0		ComponentResult			err			= noErr;		try {			// Find a vdig-itizer.			ComponentDescription	theDesc;						// Find and open a sequence grabber			theDesc.componentType			= videoDigitizerComponentType;			theDesc.componentSubType		= subType;					theDesc.componentManufacturer	= manufacturer;			theDesc.componentFlags			= nil;			theDesc.componentFlagsMask		= nil;			Component			sgCompID	= nil;					// Find a vdig component that matches ou criteria.		sgCompID = FindNextComponent(nil, &theDesc);		if ( sgCompID == nil ) throw cantFindHandler;	// None found.					// Open the component, This may fail for two reasons.			//	1. a problem with the vdig or			//	B. the vdig is already instantiated and being used elsewhere.		vdig = OpenComponent(sgCompID);		if ( vdig == nil ) throw cantOpenHandler;		// failed;			// Fill in my info record.		err = VDGetDigitizerInfo( vdig, &vdigInfo );		if ( err != noErr ) throw rc;			// Fetch the maximum input rectangle.		Rect	maxSource;		err = VDGetMaxSrcRect( vdig, 0, &vdigMaxRect );		if ( err != noErr ) throw rc;				// Obtain Default values;		err = VDGetVideoDefaults( vdig, &vdigBlackLevel, &vdigWhiteLevel, &vdigBrightness, &vdigHue, 										&vdigSaturation, &vdigContrast, &vdigSharpness );		if ( err != noErr ) throw rc;		}	catch(  ComponentResult rc ) {		CloseComponent(vdig);		vdig = nil;		throw rc;	// for a superior handler.		}	// How many inout does this vdig have?	VDGetNumberOfInputs( vdig, &vdigInputs );	// Dis is US of A.  We do ntsc!	VDSetInputStandard( vdig, ntscIn );		// start by assuming the maximum frame.	::SetRect( &videoFrame, 0, 0, vdigMaxRect.right-vdigMaxRect.left, vdigMaxRect.bottom-vdigMaxRect.top );	// Initially digitize the whole maximum input rectangle.	CaptureRectangle( videoFrame );	// Set the default frame rate, if supported.  We will ignore any errors.	VDSetFrameRate( vdig, 0 );	// And an identity matrix	SetIdentityMatrix( &videoMatrix );		// Capture mask	videoMask = nil;	// Set mode and depth, color and maxdepth	SetMode( true, 0 );	// no buffers, initally	bufferIndex = bufferCount = -1;	// Finally update the flags.	UpdateFlags();}//	Destruction routine.CVDig::~CVDig( void ){	// Clean up	if (vdig != nil) {		// free up any buffers, if any were allocated.		DestroyGWorld();		DestroyBuffers();		// close component.		CloseComponent( vdig );		vdig = nil;		}}#pragma mark	-#pragma mark	¥ Public MethodsRectCVDig::CaptureRectangle( void ){	Rect	r;	VDGetDigitizerRect( vdig, &r );	return r;}voidCVDig::CaptureRectangle( Rect r ){	// we should adjust r to fit within the limits provided.	if ( SectRect ( &r,	&vdigMaxRect, &r ) )	// they intersect and are adjusted.		VDSetDigitizerRect( vdig, &r );}// Given a rectangle, return the optimal rectangle given the capabilities of this digitizer.// This method doesn't affect any of the instance values.  It simply provides the best view.RectCVDig::BestVideoRect( const Rect& r )	{	Rect	dr;	VDGetDigitizerRect( vdig, &dr );	if ( (r.bottom - r.top) == (dr.bottom - dr.top) && (r.right - r.left) == (dr.right - dr.left) ) {		// No problem, perfect match.		return r; 		}	if ( vdigInfo.outputCapabilityFlags & digiOutDoesShrink ) {		// piece of cake.  Just specify a transformation matrix.		return r; 		}	if ( vdigInfo.outputCapabilityFlags & digiOutDoesStretch ) {		// piece of cake.  Just specify a transformation matrix.		return r; 		}	// tricky stuff. digitizer can only acomodate certain scalings.	short rHgt = (r.bottom - r.top);	short rWid = (r.right - r.left);		short dHgt = (dr.bottom - dr.top);	short dWid = (dr.right - dr.left);	Rect	rr = dr;		rr.right = rr.left + (dr.right - dr.left);		rr.bottom = rr.top + (dr.bottom - dr.top);		if ( rHgt < dHgt && rWid < dWid ) { // shrink		if ( rHgt*4 >= dHgt && rWid*4 >= dWid && vdigInfo.outputCapabilityFlags & digiOutDoesSixteenth ) {			rr.right = rr.left + (dr.right - dr.left)/4;			rr.bottom = rr.top + (dr.bottom - dr.top)/4;			}		if ( rHgt*2 >= dHgt && rWid*2 >= dWid && vdigInfo.outputCapabilityFlags & digiOutDoesQuarter ) {			rr.right = rr.left + (dr.right - dr.left)/2;			rr.bottom = rr.top + (dr.bottom - dr.top)/2;			}		}	if ( rHgt > dHgt && rWid > dWid ) { // stretch		if ( rHgt >= 2*dHgt && rWid >= 2*dWid && vdigInfo.outputCapabilityFlags & digiOutDoesDouble ) {			rr.right = rr.left + (dr.right - dr.left)*2;			rr.bottom = rr.top + (dr.bottom - dr.top)*2;			}		if ( rHgt >= 4*dHgt && rWid >= 4*dWid && vdigInfo.outputCapabilityFlags & digiOutDoesQuad ) {			rr.right = rr.left + (dr.right - dr.left)*4;			rr.bottom = rr.top + (dr.bottom - dr.top)*4;			}		}	return rr;}//// Set up the video rectangle and transformation matrix.RectCVDig::OptVideoRect( const Rect& r ){	videoFrame = BestVideoRect( r );	// Reset the matrix	SetIdentityMatrix( &videoMatrix );	Rect	dr;	VDGetDigitizerRect( vdig, &dr );	RectMatrix ( &videoMatrix, &dr, &videoFrame );//	if ( flipHorizontal() )	ScaleMatrix	 ( &videoMatrix, Fixed(-1), Fixed(1), Fixed aboutX, Fixed aboutY);//	if ( flipVertical() )	ScaleMatrix	 ( &videoMatrix, Fixed(-1), Fixed(1), Fixed aboutX, Fixed aboutY);	return videoFrame;	//	short n = bufferCount;//	ClearUpBuffers();		// Clear the old buffer//	SetUpBuffers( n );		// Set the new buffers}////	Set and return the current input soucevoidCVDig::InputSource( short src ){	// limit choices.	if ( src < 0 ) src = 0;	if ( src > vdigInputs ) src = vdigInputs;	VDSetInput( vdig, src );}shortCVDig::InputSource( void ){		short	b = 0;	VDGetInput( vdig, &b );	return b;}// void			CVDig::Contrast( unsigned short c ){	VideoDigitizerError	err;	err = VDSetContrast( vdig, &c );	if ( err != noErr ) throw err;	// The only error we are likely to throw is the digiUnimpErr error.}unsigned short	CVDig::Contrast( void ){		VideoDigitizerError	err;		unsigned short	b = 0;	err = VDGetContrast( vdig, &b );	if ( err != noErr ) throw err;	// The only error we are likely to throw is the digiUnimpErr error.	return b;}voidCVDig::Brightness( unsigned short b ){	VideoDigitizerError	err;	err = VDSetBrightness( vdig, &b );	if ( err != noErr ) throw err;	// The only error we are likely to throw is the digiUnimpErr error.}unsigned shortCVDig::Brightness( void ){		unsigned short	b = 0;	VDGetBrightness( vdig, &b );	return b;}voidCVDig::SetMode( Boolean color, short depth ){	// Set the default colormode, if supported.	//	Unless the color capability flag is set, we can only do B&W.	digiMode = 0;	// default	if ( vdigInfo.inputCapabilityFlags & digiInDoesColor )	digiMode = color;	VDSetInputColorSpaceMode( vdig, digiMode );	// figure out what's allowed, default to request or highest supported value.	if ( vdigInfo.outputCapabilityFlags & digiOutDoes1  )	digiDepth = 1;	if ( vdigInfo.outputCapabilityFlags & digiOutDoes2  )	digiDepth = 2;	if ( vdigInfo.outputCapabilityFlags & digiOutDoes4  )	digiDepth = 4;	if ( vdigInfo.outputCapabilityFlags & digiOutDoes8  )	digiDepth = 8;	if ( vdigInfo.outputCapabilityFlags & digiOutDoes16 )	digiDepth = 16;	if ( vdigInfo.outputCapabilityFlags & digiOutDoes32 )	digiDepth = 32;	// change per request, if request is valid.	switch ( depth )	{		case 1:			if ( vdigInfo.outputCapabilityFlags & digiOutDoes1 )	digiDepth = 1;			break;		case 2:			if ( vdigInfo.outputCapabilityFlags & digiOutDoes2  )	digiDepth = 2;			break;		case 4:			if ( vdigInfo.outputCapabilityFlags & digiOutDoes4  )	digiDepth = 4;			break;		case 8:			if ( vdigInfo.outputCapabilityFlags & digiOutDoes8  )	digiDepth = 8;			break;		case 16:			if ( vdigInfo.outputCapabilityFlags & digiOutDoes16 )	digiDepth = 16;			break;		case 32:			if ( vdigInfo.outputCapabilityFlags & digiOutDoes32 )	digiDepth = 32;			break;		}	// Finally update the flags.	UpdateFlags();}voidCVDig::PlayThrough( GrafPtr window, Rect& rectInWindow ){	ComponentResult err;	// We do playthrough based on the capabilities of the digitizer...		// This call adjusts the requested rectangle to something we can manage.	Rect rr = OptVideoRect( rectInWindow );		Boolean	canDo = false;	if ( vdigInfo.outputCapabilityFlags & digiOutDoesHW_DMA ) {		// We can anticipate a problem if DMAdepth doesn't suppor the depth of the grafPort			long dArr, pDep;		err = VDGetDMADepths( vdig, &dArr, &pDep );		if ( err ) throw err;				// determine the port depth and capabilities:		if ( ((CGrafPtr)window)->portVersion && 0xC000 ) {	// a cGrafPort			switch( (**(((CGrafPtr)window)->portPixMap)).pixelSize )	{				case 1:					canDo = dArr & dmaDepth1;	break;				// Since there isn't a simple way to figure out if the cGrafPort is set				//	up to display gray scales we just assume it is correct.  All that				//	happens is that the output looks funny.				case 2:					canDo = dArr & dmaDepth2 || dArr & dmaDepth2Gray;	break;				case 4:					canDo = dArr & dmaDepth4 || dArr & dmaDepth4Gray;	break;				case 8:					canDo = dArr & dmaDepth8 || dArr & dmaDepth8Gray;	break;				case 16:					canDo = dArr & dmaDepth16;	break;				case 32:					canDo = dArr & dmaDepth32;	break;				}			}		else {			canDo = dArr & dmaDepth1;			}				}		if ( vdigInfo.outputCapabilityFlags & digiOutDoesHW_DMA && canDo && 	     vdigInfo.outputCapabilityFlags & digiOutDoesHWPlayThru ) {		// If vdig supports hardware DMA and the depth and mode requested then 		//	we try to play directly to screen.		//	rectInWindow  would be paneRect or contentRegionRect		err = VDPreflightGlobalRect( vdig, window, &rr );		if ( err ) throw err;		// If an error was going to occur then the previous call should have done it.		err = VDSetPlayThruGlobalRect( vdig, window, &rr );		if ( err ) throw err;	// shouldn't happen here.		}	else if ( vdigInfo.outputCapabilityFlags & digiOutDoesHW_DMA && canDo ) {		// We can't play to the screen asynchronously without somekind of timing loop but we can		//	write directly to the screen.		// preflight and allow digitizer to adjust things.  Notice that if buffers have been formed		// The topmost rect in the GWorld is assumed to be the playthrough rect.		err = VDPreflightDestination( vdig, &videoFrame, ((CGrafPtr)window)->portPixMap, &rr, nil );			if ( err && err!=qtParamErr ) throw err;		// If an error was going to occur then the previous call should have done it.		err = VDSetPlayThruDestination( vdig, ((CGrafPtr)window)->portPixMap, &rr, nil, nil );			if ( err ) throw err;				}	else {		// If we can't play through, all digitizers are guaranteed to playthru to a PixMap,		//	however "void where prohibited some restrictions may apply."		// make sure we have a gWorld.		if ( gWorld == nil ) CreateGWorld( rectInWindow );				// preflight and allow digitizer to adjust things.  Notice that if buffers have been formed		// The topmost rect in the GWorld is assumed to be the playthrough rect.		err = VDPreflightDestination( vdig, &videoFrame, GetGWorldPixMap(gWorld), &rr, nil );			if ( err && err!=qtParamErr ) throw err;		// If an error was going to occur then the previous call should have done it.		err = VDSetPlayThruDestination( vdig, GetGWorldPixMap(gWorld), &rr, nil, nil );			if ( err ) throw err;		}}voidCVDig::SpotMeter( unsigned short b ){	// set the target spot meter	bright = float(b) / float(USHRT_MAX);}voidCVDig::SpotMeter( const Rect& r ){	// Given a rectangle r = to or inside the video rect	//  This function will automatically set the brightness.	//	N.B. a single call to this function won't do the trick.	//		the "servo" needs a couple of passes to stabilize.	//		Moreover, this function is not optimized to run fast	//		so it isn't intended to run all the time.  You might	//		connect it to some user interface like a button for	//		momentary adjustment for example.	unsigned short	b;	long			avgPixel = 0L;	if ( bufferIndex < 0 )	// no buffers.		b = 0;	else {					// buffers.		// Set b to the previous buffer index		b = (bufferIndex==0 ? bufferCount : bufferIndex) - 1 ;			// wait for the buffer to be filled.		if ( vdig )			while( !VDDone( vdig, b ) );		}	// No buffer, no metering.	if ( gWorld ) {		Rect	bufferFrame = videoFrame;		Rect	mapFrame	= r;		// Move it to the buffer's position.		::OffsetRect( &bufferFrame, 0, b * (videoFrame.bottom-videoFrame.top) );		MapRect(&mapFrame,&videoFrame,&bufferFrame); 		PixMapHandle	pm = GetGWorldPixMap(gWorld);		LockPixels( pm );	// Lock 'em		{	// guarantee _base_ never gets used outside Locked PixMap			Ptr		base		= GetPixBaseAddr( pm );			short	rowBytes	= (**pm).rowBytes & 0x4FFF;			// remember, 4bits per pixel! vvv			for( int h=r.left; h < r.right/2; h++ )				for ( int v=r.top; v < r.bottom; v++ ) {					avgPixel +=  0xF & *(base+h+(v*rowBytes));					avgPixel +=  0xF & (*(base+h+(v*rowBytes)))>>4;					}		}		UnlockPixels( pm );	// Unlock 'em				// Servo 101, develop a position error signal.		//	0.	avgPixel is maximum for a dark screen, minimum for a white screen.		//	1.  This is the avg brightness in range from 0 ² <avgPix> ² 1, 1 is white.		float	avgPix = 1.0 - float(avgPixel)/(30.0*float(r.bottom-r.top)*float(r.right-r.left));		//				 1 -> see 0 above		30 -> 2 pixels / byte * 15 maxSig / pixel.		//	2. develop target error signal		float	error = bright - avgPix;		//	now if we are spot on (pun intended) then error is 0 and we do nothing.		//		if it is < 0 then we decrease the vdig brightness.		//		if it is > 0 then we increase the vdig brightness.		//		-1.0 ² error ² 1.0		// Develop a factor which allows for a complete metering		error *= 0.95; 	// dampenning factor (arb. number)		if ( error*error > 0.0025 ) { // tolerance threshold for control. (arb. number)			unsigned short brightFactor = Brightness();  // current value			if ( error > 0 )				brightFactor += (USHRT_MAX-brightFactor)*error;	// error is positive			else				brightFactor += brightFactor * error;			// error is negative or zero			// reset brightness.			Brightness( brightFactor );			}		// There are a lot of floating calculations in here.  That may seem scary and ripe for		// optimization, but these calculations aren't the speed bottleneck for this function.		}	}voidCVDig::UpdateVideo( void ){	if ( !vdig ) throw cantFindHandler;	if ( bufferIndex < 0 )		VDGrabOneFrame( vdig );	else {		VDGrabOneFrameAsync( vdig, bufferIndex++ );		bufferIndex = bufferIndex % bufferCount;		}	// Update flags	UpdateFlags();}voidCVDig::flipHorizontal( Boolean flip ){	// flip it.	It doesn't work!  At least not through the usual mechanisms.//	hFlip = flip;//	OptVideoRect( videoFrame );}BooleanCVDig::flipHorizontal( void ){			// horiz flip state	if ( vdigInfo.outputCapabilityFlags & digiOutDoesHorizFlip )		return hFlip;	hFlip = false;	return hFlip;}voidCVDig::flipVertical( Boolean flip ){	// flip it.	It doesn't work!   At least not through the usual mechanisms.//	vFlip = flip;//	OptVideoRect( videoFrame );//#endif}BooleanCVDig::flipVertical( void ){			// vert flip state	if ( vdigInfo.outputCapabilityFlags & digiOutDoesVertFlip )		return vFlip;	vFlip = false;	return vFlip;}#pragma mark	-#pragma mark	¥ Action methods	PicHandleCVDig::GrabPict( void ){	OpenCPicParams	pp;		pp.srcRect = videoFrame;	pp.hRes =  0x00480000;	pp.vRes =  0x00480000;	pp.version = -2;	pp.reserved1 = 0;	pp.reserved2 = 0;			GWorldPtr		savePort;		GDHandle		saveGD;			GetGWorld( &savePort, &saveGD );	SetGWorld( gWorld, nil );		PicHandle p = OpenCPicture( &pp );	UpdateVideo();	DrawVideo( gWorld, videoFrame );	ClosePicture();	SetGWorld( savePort, saveGD );		return p;	}voidCVDig::DrawVideo( CGrafPtr gw, const Rect& r ){	short b;	if ( bufferIndex < 0 )	// no buffers.		b = 0;	else {					// buffers.		// Set b to the previous buffer index		b = (bufferIndex==0 ? bufferCount : bufferIndex) - 1 ;			// wait for the buffer to be filled.		if ( vdig )			while( !VDDone( vdig, b ) );		}	// if we have a display gWorld	// To handle multiple buffers I need to devlop a scheme for addressing	//	the buffers through their respective rectangles.  Given an index	//	I need to map the rectangle to the pixMap.  I've chosen to map them	//	vertically.	if ( gWorld ) {		Rect	bufferFrame = videoFrame;		// Move it to the buffer's position.		::OffsetRect( &bufferFrame, 0, b * (videoFrame.bottom-videoFrame.top) );				LockPixels( GetGWorldPixMap(gWorld) );		CopyBits(	&((GrafPtr)gWorld)->portBits,	&((GrafPtr)gw)->portBits,					&bufferFrame, 					&r,					srcCopy, nil );		UnlockPixels( GetGWorldPixMap(gWorld) );		}}DigitizerInfoCVDig::GetInfoRecord( void ){	return vdigInfo;}#pragma mark	-#pragma mark	¥ Protected methods	// Create a gWorld that matches the current depth requests.//	We have a number of considerations here.//		if the depth is less than 8 and the device supports ILUT then we create our own//		otherwise we get the LUT from the device.voidCVDig::CreateGWorld( Rect& bufferFrame ){	CTabHandle	ct = nil;	ComponentResult err;	DestroyGWorld();	// get rid of the old one.	// Only deal with LUTs if the depth is < 16	if ( digiDepth < 16 ) {		if ( vdigInfo.outputCapabilityFlags & digiOutDoesILUT ) {			// we get a standard table			short		clutIndex = (digiMode ? 32 : 64) + digiDepth;			ct	= GetCTable(clutIndex);			if ( digiDepth == 8 && digiMode == 1 )	// pge 8-61 sez this is only useful for this situation				VDUseThisCLUT( vdig, ct );			}		else {			// We can't set the lookup table so we try to get one.			err = VDGetCLUTInUse( vdig, &ct );			if ( err==memFullErr ) throw err;	// bomb.			if ( err==digiUnimpErr ) {	// homey don't play this, get a standard one.				// we get a standard table				short		clutIndex = (digiMode ? 32 : 64) + digiDepth;				ct	= GetCTable(clutIndex);				}						}		}	// build the gWorld	NewGWorld( &gWorld, digiDepth, &bufferFrame, ct, nil, 0 );	if ( ct )	DisposeHandle( (Handle) ct );  // GWorld copied it.	if ( gWorld == nil ) throw memFullErr;}voidCVDig::DestroyGWorld( void ){	if ( gWorld ) {		// gets rid of the clut automatically		DisposeGWorld( gWorld );		gWorld = nil;		}		}voidCVDig::CreateBuffers( short n ){	// The videoFrame contains the rectangle required for capture.		VideoDigitizerError rc;	//	I propose the following scheme for buffering:	//		Allocate one GWorld with a huge pixMap  Width x n Height	//		rectangle.  Define the pixMaps in the buffer array to be	//		the same pm and different location to start points along	//		the way.  ¥ I assume that videoFrame is set to reflect the	//		area to be digitized.	// BW QuickCam captures 16 levels of gray, choose an appropos clut.	short	depth = 4;	Rect	bufferFrame;	gWorld = nil;		// use the current video frame.	bufferCount = n;	bufferFrame = videoFrame;	if ( n > 0 ) // if we want a buffer, set aside a big enough area.		bufferFrame.bottom *= n;	// We want a GWorld in any case.	CreateGWorld( bufferFrame );	if ( n > 0 ) { // Yes we want to buffer data.		VdigBufferRecListHandle		vdigBuffers	=	(VdigBufferRecListHandle) NewHandle( sizeof(VdigBufferRecList) + (n-1)*sizeof(VdigBufferRec) );		if ( !vdigBuffers ) throw dsMemFullErr;			HLock( (Handle) vdigBuffers );		(**vdigBuffers).count = bufferCount;		(**vdigBuffers).matrix = &videoMatrix;		(**vdigBuffers).mask = nil;		short height = videoFrame.bottom - videoFrame.top;		for( int j = 0; j < n; j++ ) {			((**vdigBuffers).list[j]).dest		= GetGWorldPixMap(gWorld);			::SetPt( &((**vdigBuffers).list[j]).location, 0, j * height ); 			((**vdigBuffers).list[j]).reserved	= 0L;			}				// If we lock it we gotta unlock it.		HUnlock( (Handle) vdigBuffers );				// Set the buffers			rc = VDSetupBuffers( vdig, vdigBuffers );		DisposeHandle( (Handle) vdigBuffers );		if ( rc ) throw rc;			bufferIndex = 0;		}	else { // no we do not want to buffer so we preflight and PlayThru the pixMap.		rc = VDPreflightDestination( vdig, &videoFrame, GetGWorldPixMap(gWorld), &videoFrame, nil );			if ( rc!=noErr && rc!=qtParamErr ) throw rc;		rc = VDSetPlayThruDestination( vdig, GetGWorldPixMap(gWorld), &videoFrame, nil, nil );			if ( rc!=noErr ) throw rc;		bufferIndex = -1;		}}voidCVDig::DestroyBuffers( void ){	// i don't throw in destructors.  Too many potential problems.//	if ( bufferCount>0 )//		if ( vdig ) VDReleaseAsyncBuffers( vdig );}voidCVDig::UpdateFlags( void ){	// Get current flags.	VDGetCurrentFlags( vdig, &vdigInfo.inputCurrentFlags, &vdigInfo.outputCurrentFlags );}